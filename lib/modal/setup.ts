export interface RunManimOptions {
  code: string;                 // The Python code generated by Claude
  sceneName: string;            // The class name inside scene.py
  uploadUrl?: string;           // Optional Supabase signed URL
  timeout?: number;             // Defaults to 30 minutes
  verbose?: boolean;
  resolution?: string;          // 480p, 720p, 1080p
  aspectRatio?: string;         // 16:9, 9:16, 1:1
  duration?: number;            // Duration in seconds
  style?: string;               // auto, clean, cinematic, academic
}

export async function runManimRender({
  code,
  sceneName,
  uploadUrl,
  timeout = 1800, // 30 minutes in seconds
  verbose = false,
  resolution = "720p",
  aspectRatio = "16:9",
  duration = 8,
  style = "auto",
}: RunManimOptions) {
  console.log("üîπ Calling Modal function...");
  console.log("üîπ Scene name:", sceneName);
  console.log("üîπ Code length:", code.length, "characters");
  
  try {
    // Use Python subprocess to call Modal function directly
    const { spawn } = require('child_process');
    const fs = require('fs');
    const path = require('path');
    
    // Create a temporary Python script file
    const tempScriptPath = path.join(__dirname, 'temp_modal_script.py');
    const tempScript = `
import modal
import json
import sys
import os

try:
    # Set up Modal token
    os.environ['MODAL_TOKEN_ID'] = '${process.env.MODAL_TOKEN_ID}'
    os.environ['MODAL_TOKEN_SECRET'] = '${process.env.MODAL_TOKEN_SECRET}'
    
    # Add the current directory to Python path
    sys.path.insert(0, os.getcwd())
    
    # Import the app and function directly
    from modal_functions.manim_render import app, render_manim
    
    # Read parameters from command line arguments
    scene_name = sys.argv[1]
    upload_url = sys.argv[2] if len(sys.argv) > 2 and sys.argv[2] != 'None' else None
    openai_api_key = sys.argv[3] if len(sys.argv) > 3 and sys.argv[3] != 'None' else None
    resolution = sys.argv[4] if len(sys.argv) > 4 and sys.argv[4] != 'None' else '720p'
    aspect_ratio = sys.argv[5] if len(sys.argv) > 5 and sys.argv[5] != 'None' else '16:9'
    duration = int(sys.argv[6]) if len(sys.argv) > 6 and sys.argv[6] != 'None' else 8
    style = sys.argv[7] if len(sys.argv) > 7 and sys.argv[7] != 'None' else 'auto'
    
    # Read the code from stdin
    code = sys.stdin.read()
    
    # Use the app context to run the function
    with app.run():
        result = render_manim.remote(
            code=code,
            scene_name=scene_name,
            upload_url=upload_url,
            openai_api_key=openai_api_key,
            resolution=resolution,
            aspect_ratio=aspect_ratio,
            duration=duration,
            style=style
        )
    
    print(json.dumps(result))
except Exception as e:
    print(json.dumps({"success": False, "error": str(e)}))
`;
    
    // Write the script to a temporary file
    fs.writeFileSync(tempScriptPath, tempScript);
    
    return new Promise((resolve) => {
      const pythonProcess = spawn('python', [
        tempScriptPath,
        sceneName,
        uploadUrl || 'None',
        process.env.OPENAI_API_KEY || 'None',
        resolution,
        aspectRatio,
        duration.toString(),
        style
      ], {
        stdio: ['pipe', 'pipe', 'pipe'],
        cwd: process.cwd()  // Run from project root
      });
      
      let output = '';
      let errorOutput = '';
      
      pythonProcess.stdout.on('data', (data) => {
        output += data.toString();
      });
      
      pythonProcess.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });
      
      // Send the code via stdin
      pythonProcess.stdin.write(code);
      pythonProcess.stdin.end();
      
      pythonProcess.on('close', (code) => {
        // Clean up the temporary script file
        try {
          fs.unlinkSync(tempScriptPath);
        } catch (e) {
          // Ignore cleanup errors
        }
        
        try {
          const result = JSON.parse(output);
          
          if (verbose) {
            console.log("üìä STDOUT:", result.logs);
            console.log("‚ö†Ô∏è STDERR:", result.stderr);
          }
          
          if (result.success) {
            console.log("‚úÖ Render completed successfully!");
            resolve({
              success: true,
              outputUrl: uploadUrl,
              logs: result.logs,
              stderr: result.stderr,
            });
          } else {
            console.error("‚ùå Modal error:", result.error);
            resolve({
              success: false,
              error: result.error,
              logs: result.logs || "",
              stderr: result.stderr || result.error,
            });
          }
        } catch (parseError) {
          console.error("‚ùå Failed to parse Modal response:", parseError);
          console.error("Raw output:", output);
          console.error("Error output:", errorOutput);
          resolve({
            success: false,
            error: `Failed to parse response: ${parseError.message}`,
            logs: output,
            stderr: errorOutput,
          });
        }
      });
    });
  } catch (err) {
    console.error("‚ùå Modal error:", err);
    return {
      success: false,
      error: (err as Error).message,
      logs: "",
      stderr: (err as Error).message,
    };
  }
}

// Helper function to get Manim quality flag based on resolution
export function getManimQualityFlag(resolution: string): string {
  const qualityMap: Record<string, string> = {
    '480p': '-ql',  // Low quality
    '720p': '-qh',  // High quality (default)
    '1080p': '-qk', // 4K quality
  };
  return qualityMap[resolution] || '-qh';
}

// Helper function to get Manim resolution string from aspect ratio and resolution
export function getManimResolution(aspectRatio: string, resolution: string): string {
  // Extract height from resolution (480p, 720p, 1080p)
  const height = parseInt(resolution.replace('p', ''));
  
  // Calculate width based on aspect ratio
  let width: number;
  switch (aspectRatio) {
    case '16:9':
      width = Math.round(height * 16 / 9);
      break;
    case '9:16':
      width = Math.round(height * 9 / 16);
      break;
    case '1:1':
      width = height;
      break;
    default:
      // Default to 16:9
      width = Math.round(height * 16 / 9);
  }
  
  return `${width}x${height}`;
}

// Helper function to get output path based on resolution
export function getManimOutputPath(sceneName: string, resolution: string): string {
  const qualityFlag = getManimQualityFlag(resolution);
  const qualityFolder = qualityFlag.replace('-q', '');
  
  // Map quality flags to folder names
  const folderMap: Record<string, string> = {
    'l': '480p15',
    'h': '720p30', 
    'k': '1080p60',
  };
  
  const folder = folderMap[qualityFolder] || '720p30';
  return `media/videos/scene/${folder}/${sceneName}.mp4`;
}

